内容参考IBM官网
https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html

ByteBuffer 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：

    ByteBuffer
    CharBuffer
    ShortBuffer
    IntBuffer
    LongBuffer
    FloatBuffer
    DoubleBuffer
每一个 Buffer 类都是 Buffer 接口的一个实例。 除了 ByteBuffer，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。
因为大多数标准 I/O 操作都使用 ByteBuffer，所以它具有所有共享的缓冲区操作以及一些特有的操作。     
现在您可以花一点时间运行 UseFloatBuffer.java，它包含了类型化的缓冲区的一个应用例子。 
什么是通道？

Channel是一个对象，可以通过它读取和写入数据。
拿 NIO 与原来的 I/O 做个比较，通道就像是流。

正如前面提到的，所有数据都通过 Buffer 对象来处理。
您永远不会将字节直接写入通道中，相反，
您是将数据写入包含一个或者多个字节的缓冲区。
同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，
再从缓冲区获取这个字节。 

<h1>通道类型</h1>

通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道 可以用于读、写或者同时用于读写。

因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。

<h1>从理论到实践：NIO 中的读和写</h1>

读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中。写入也相当简单：
创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。
在本节中，我们将学习有关在 Java 程序中读取和写入数据的一些知识。我们将回顾 NIO 的主要组件(缓冲区、通道和一些相关的方法)，
看看它们是如何交互以进行读写的。在接下来的几节中，我们将更详细地分析这其中的每个组件以及其交互。 
<h2>从文件中读取</h2>
在我们第一个练习中，我们将从一个文件中读取一些数据。如果使用原来的 I/O，那么我们只需创建一个 FileInputStream 并从它那里读取。而在 NIO 中，情况稍有不同：我们首先从 FileInputStream 获取一个 Channel 对象，然后使用这个通道来读取数据。

在 NIO 系统中，任何时候执行一个读操作，您都是从通道中读取，但是您不是 直接 从通道读取。因为所有数据最终都驻留在缓冲区中，所以您是从通道读到缓冲区中。

因此读取文件涉及三个步骤：(1) 从 FileInputStream 获取 Channel，(2) 创建 Buffer，(3) 将数据从 Channel 读到 Buffer 中。

现在，让我们看一下这个过程。 

<h2>三个容易的步骤</h2>
<p>第一步是获取通道。我们从 FileInputStream 获取通道：
   1
   2
   	
   FileInputStream fin = new FileInputStream( "readandshow.txt" );
   FileChannel fc = fin.getChannel();
   </p>
  <p> 下一步是创建缓冲区：
   1
   	
   ByteBuffer buffer = ByteBuffer.allocate( 1024 );
   </p>
   <p> 最后，需要将数据从通道读到缓冲区中，如下所示：
         1
         fc.read( buffer );
    </p>
  您会注意到，我们不需要告诉通道要读 多少数据 到缓冲区中。
  每一个缓冲区都有复杂的内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据。
  我们将在 缓冲区内部细节 中介绍更多关于缓冲区统计机制的内容。
   <h2>写入文件</h2>
   <p>
   在 NIO 中写入文件类似于从文件中读取。首先从 FileOutputStream 获取一个通道：
    1
    2
    	
    FileOutputStream fout = new FileOutputStream( "writesomebytes.txt" );
    FileChannel fc = fout.getChannel();
   </p>
   <p>
   下一步是创建一个缓冲区并在其中放入一些数据 - 在这里，
   数据将从一个名为 message 的数组中取出，
   这个数组包含字符串 "Some bytes" 的 ASCII 字节(本教程后面将会解释 buffer.flip() 和 buffer.put() 调用)。 
 
  	
  ByteBuffer buffer = ByteBuffer.allocate( 1024 );
   
  for (int i=0; i<message.length; ++i) {
       buffer.put( message[i] );
  }
  buffer.flip();
  最后一步是写入缓冲区中：
  
  	
  fc.write( buffer );
  注意在这里同样不需要告诉通道要写入多数据。
  缓冲区的内部统计机制会跟踪它包含多少数据以及还有多少数据要写入。 
   </p>
   <h1>读写结合</h1>
   <p>
   下面我们将看一下在结合读和写时会有什么情况。我们以一个名为 CopyFile.java 的简单程序作为这个练习的基础，
   它将一个文件的所有内容拷贝到另一个文件中。CopyFile.java 执行三个基本操作：
   首先创建一个 Buffer，然后从源文件中将数据读到这个缓冲区中，然后将缓冲区写入目标文件。这个程序不断重复 ― 读、写、读、写 ― 直到源文件结束。 
  CopyFile 程序让您看到我们如何检查操作的状态，以及如何使用 clear() 和 flip() 方法重设缓冲区
  ，并准备缓冲区以便将新读取的数据写到另一个通道中。 
   </p>
  <h1>运行 CopyFile 例子</h1> 
   <p>因为缓冲区会跟踪它自己的数据，所以 CopyFile 程序的内部循环 (inner loop) 非常简单，如下所示：
      
 
      fcin.read( buffer );
      fcout.write( buffer );
      第一行将数据从输入通道 fcin 中读入缓冲区，第二行将这些数据写到输出通道 fcout 。 
      </p>
      <h1>检查状态</h1>
      <p>下一步是检查拷贝何时完成。当没有更多的数据时，拷贝就算完成，并且可以在 read() 方法返回 -1 是判断这一点，如下所示：
       
         int r = fcin.read( buffer );
          
         if (r==-1) {
              break;
         }
         
         </p>
        <h1>重设缓冲区</h1> 
        <p>最后，在从输入通道读入缓冲区之前，我们调用 clear() 方法。同样，在将缓冲区写入输出通道之前，我们调用 flip() 方法，如下所示：
        
           	
           buffer.clear();
           int r = fcin.read( buffer );
            
           if (r==-1) {
                break;
           }
            
           buffer.flip();
           fcout.write( buffer );
          
           clear() 方法重设缓冲区，使它可以接受读入的数据。
            flip() 方法让缓冲区可以将新读入的数据写入另一个通道。
             </p>
             <h1>缓冲区内部细节</h1>
             <h2>概述</h2> 
             <p>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。
              状态变量是前一节中提到的"内部统计机制"的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。 
              在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 访问方法 get() 来完成的。
              同样，如果要将原始数据放入缓冲区中，就要使用访问方法 put()。 
              
              在本节中，您将学习关于 NIO 中的状态变量和访问方法的内容。我们将描述每一个组件，
              并让您有机会看到它的实际应用。虽然 NIO 的内部统计机制初看起来可能很复杂，但是您很快就会看到大部分的实际工作都已经替您完成了。
              您可能习惯于通过手工编码进行簿记 ― 即使用字节数组和索引变量，现在它已在 NIO 中内部地处理了。
              
              </p>
              <h1>状态变量</h1>
              <p>可以用三个值指定缓冲区在任意时刻的状态：
                 
                     position
                     limit
                     capacity
                     这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。
                     我们将在下面的小节中详细分析每一个变量，还要介绍它们如何适应典型的读/写(输入/输出)进程。
                     在这个例子中，我们假定要将数据从一个输入通道拷贝到一个输出通道。 
                     Position
                     
                     您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。
                      position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。
                      因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。
                     
                     同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，
                     它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，
                     指向数组的第六个元素。 
                     </p>
                     <h1>Limit</h1>
                     <p>limit 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。
                        
                        position 总是小于或者等于 limit。 
                        </p>
                     <h1>Capacity</h1>
                     <p>缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。
                        
                        limit 决不能大于 capacity。 
                        </p>   